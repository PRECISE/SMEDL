-PEDL:
    Monitor constructor
        DONE:
            -Defines where in the code to initialize a monitor. Placement is based on instantiation of a struct of parameters 
            (e.g. MeanderData using keyword 'create' in the PEDL)
            -Defines initialization of internal state variable through mapping from parameter struct variables. This is specifically for monitor variables tied to the code, as opposed to internal SMEDL variables set within the monitor)
        TODO:
            -Automated insertion of monitor initialization in code (We have only done this manually). It needs to be done at the point where all the values are set within the struct. Hard to tell when that is, unless there's an init or validate function for that struct
            -Support initialization helper functions (e.g. memory management for non-primitive state variables)
            -PEDL for when to turn off or deconstruct monitors
    Event probes
        DONE:
            -Define placement of probes at every update of a variable of interest, or a call or return of a function. These categories seem to cover event of interest such as system calls and inter-process communication.
            -For call, probe is placed just inside function call
            -For return, temp var is set to return value, probe function is called with temp var, then temp var returned
        TODO:
            -Generating 'return' event functions
            -Automated probe placement
            -Use of 'when' conditions to reduce probe placement with conditions in static analysis phase. Conditions are only used in SMEDL to determine transitions at probe. Conditions based on call stack, scope or value of variables, etc could be used to reduce the number of places to add a probe.
-SMEDL:
    State transitions
        DONE:
            -Defines state machine transitions and alarms, with optional conditions on events based on imported or internally modified variables and helper functions
            -On an event, switch through scenarios in this SMEDL object (in the order that scenarios are defined in the SMEDL). Make stated transitions. If no transition stated, print error to stdout and continue from current state (instead of transitioning to new state or error state).
            -Regarding actions: state variables are set immediately. A queue is used for raised events as part of an action, and executed at the end of the event function after the state transition is made.
            -'this' keyword used to reference internal state variable and events
            -internal SMEDL variables are initialized and set in the SMEDL, as opposed to PEDL variables that are set based on variables in the source code.
            -Traces may contain no explicitly named states besides start and end states, only implicit states
            -Exception semantics - if any when condition evaluates false in the trace, the 'when' clause is executed. If there is no 'when' the standard error is raised.
            -Chose to ignore 'instantiation events', since new monitor creation can be specified with monitor constructors in the PEDL
        TODO:
            -Flags to disable error raises for specific events on state where transition is not explicitly defined (Options: flag for all scenarios in SMEDL object, or just specific scenarios). The intention is to reduce the number of transitions that need to be explicitly stated inthe SMEDL file.
            -Model checking of SMEDL FSMs - looking for potential deadlock
                -Raising events back in forth in a circular manner is a problem
                -Nondeterminism from same explicitly named state on same event in same scenario
                -Warn about terminal states?
            -Add boolean as state variable type 
            -Resolve issue of triggering multiple events at the same point in code. Order of the event probes would matter.
            -Native timer/timeout events - traces that check time elapsed during occurrences of events can be done using a helper function extension that sets an internal smedl variable based on system time. But it would be nice as a built-in SMEDL feature
            -Cross-validate import/export events
            -Raise queue (don't add raise to symbolTable, but check that it references int or exp event)

-Code generation:
    In C:
        DONE:
            -Currently using probes as direct function calls that evaluate SMEDL in the process' main thread. These events are evaluated immediately, in-line with no buffer. 
            -A standard error message is printed to the console - it may be changed
            -Probes create a list of monitors pertaining to the event, then calls the event function on each of those monitors
            -A map for each identity is created, and when a monitor is created, it is added to each map. PEDL events define conditions for which monitors should be called for a given event based on their identities. The event probe uses the map for the first identity checked to create a list of monitors matching that identity. If more than one identity needs to be checked. That list is further filtered based on those identities. That seems to be more efficient than creating lists from all maps and then making of list of monitors that are part of all lists (espcially if the user used the identity that filters the list the most as the first identity checked)
            -Helper function calls in 'when' conditions and actions: {x = helper() ; raise y(x)} or {raise y(helper())}
            Should there be a keyword similar to 'raise' for calling helper functions? Can these helpers be a vehicle for checking system-level events such as system calls using other APIs?
            -Helpers take in parameters by default as void*, and the function itself casts the data as needed
            -Internal variables may be structs using the keyword 'struct' and stored in monitor as void* in C
            -Right now generation assumes that for object <ObjectName>, the monitor will be named <ObjectName>Monitor and that the parameters from the code will be contained in struct <ObjectName>Data with matching variable names and types within
        TODO:
            -Generate from multiple SMEDL object files, making FSM transitions on some similar and some different events. This may require changes in command line args and the generation of 'includes' in the C code
            -Generate monitor deconstructor, and global monitor list deconstuctor
            -Check that all monitor internal variables are mapped from source code variables via PEDL or initialized in either SMEDL or PEDL.
            -Token conflicts are common if SMEDL variables or events have the same name as source code. To test to make sure prefixes are addes sufficiently to token names in SMEDL to avoid this.
            -Add locks in event functions when dealing with state variables marked 'shared'. The user uses the keyword 'shared' to say that a variable may be accessed from multiple threads
            -Generate functions to set/reset monitor states on errors? (Likely synchronization issues)
            -Predefined monitor libraries that do univeral (system-level) checks (e.g. can we monitor system calls with the caller information? see if we expect that caller to do that? Ex of problem: calls could be made at various levels - e.g. browser API vs lower level. If we know browser API, we can add monitoring to it with our deployed version of the browser) nginx example
            -Check Else in FSM - in/out transitions should be there - pretty much only for printing
            -Use error enumeration from SMEDL to let the user define multiple error types
            -Command line arg vs smedl for main header file, multiple smedl files, helper header
            -'this.' Test functionality in both SMEDL (state var, internal event, static object references) and PEDL. It seems that in all cases, the word 'this' should be replaced with 'monitor', but this is assuming variable 'monitor' is in scope

Notes:
If an event is raised within a monitor, the event function should only be called for that monitor, right? Otherwise, if it calls the functions on all interested monitors, they may all in turn raise events, exponentially increases event calls. But then how to you export events to other monitors?
Imported events that aren't pedl events... don't make probe - but raise is for this monitor, how do you call all monitors?



