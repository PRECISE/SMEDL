# This grammar defines A4SMEDL in the Grako-variation of EBNF.

@@grammar :: A4SMEDL

#include :: "common.ebnf"

start =
    declaration ';'
    {(
        import_stmt
        | monitor_decl
        | syncset_decl
        | connection_defn
    )';'}*
    $
    ;

declaration =
    'system' ~ @:identifier
    ;

# Filename looks like a string literal but does not accept escape sequences
# (similar to #include "..." in C)
import_stmt =
    'import' ~ @:smedl_filename
    ;

smedl_filename =
    /"[^"\n\r\v\f]*"/
    ;

monitor_decl =
    'monitor' ~ name:identifier '(' params:type_list ')'
    ['as' renamed:identifier]
    ;

syncset_decl =
    'syncset' ~ name:identifier '{' monitors:identifier_list '}'
    ;

#TODO Proposed change: Instead of repeating source spec for each target spec,
# allow multiple targets for a source, and do not allow repeating a source. That
# way, there is no ambiguity about whether the same source can have different
# connection/channel names (it cannot)
#
# This would look like this:
#
# connection_defn =
#     [name:identifier ':'] source:source_spec
#     '=>' targets:'=>'.{target_spec}+
#     ;
connection_defn =
    [name:identifier ':'] source:source_spec
    '=>' target:target_spec
    ;

source_spec =
    [monitor:identifier '.'] event:identifier
    ;

target_spec =
    target_event
    | monitor_initialization
    ;

target_event =
    dest_monitor:identifier
    ['[' monitor_params:wildcard_parameter_list ']']
    '.'
    dest_event:identifier
    ['(' event_params:parameter_list ')']
    ;

monitor_initialization =
    dest_monitor:identifier
    '(' (
        # Two cases:
        # 1. There is at least one parameter (in which case, separating comma is
        #    needed)
        # 2. There is no parameter, and may or may not be state variable
        #    initializations. This is not allowed, but we allow it in the
        #    grammar so that we can catch it and display a more helpful error
        #    message in the semantics processor.
        monitor_params:parameter_list_nonempty
                [',' state_vars:initializer_list_nonempty]
        | state_vars:initializer_list
    ) ')'
    ;

initializer_list_nonempty =
    ','.{initializer}+
    ;

initializer_list =
    ','.{initializer}*
    ;

initializer =
    var_name:identifier '=' value:parameter
    ;

wildcard_parameter_list =
    ','.{wildcard_parameter}*
    ;

parameter_list_nonempty =
    ','.{parameter}+
    ;

parameter_list =
    ','.{parameter}*
    ;

wildcard_parameter =
    parameter
    | kind:'*'
    ;

parameter =
    kind:'#' index:natural
    | 'Id' kind:`'#'` '.' index:natural
    | kind:'$' index:natural
    | 'Param' kind:`'$'` '.' index:natural
    ;

natural =
    /[0-9]+/
    ;
