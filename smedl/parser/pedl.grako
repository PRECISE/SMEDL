# This grammar defines PEDL in the Grako-variation of EBNF.
#  written by Peter Gebhard

# Grako-specific directives
@@grammar :: pedl

# Object is the top-level rule for a PEDL file. We look for an 'object' keyword
# followed by the object identifier and an 'events' keyword for the section
# containing the PEDL events.
object::Object
    =
    'object' object:identifier
    'events'
        monitors:{new_mon}+
        event_defs:{event_def}+
    $
    ;

# new_mon describes how a new monitor can be created. A 'new' keyword
# followed by an identifier (shown below with the monitor label) defines
# the new monitor and its optional identities. After the equals sign, the
# 'create' keyword specifies that this new monitor should be constructed on
# the creation of a data structure named PQueueData. The contents of this
# structure are defined in the 'structure' rule.
new_mon::MonitorConstructor
    =
    'new' monitor:identifier ['(' monitor_params:identifier_list ')'] '='
        'create' struct:structure
    ;

# structure describes the data structure used by a monitor. It is defined
# by a name (the struct_id label) and a set of fields.
structure::MonitorStruct
    =
    struct_id:identifier '{' fields:{field}* '}'
    ;

# field describes a data structure field. It maps a monitor's internal state
# variable (labeled as variable) to its initial value (labeled as value).
# ex. monitor_foo = this.bar + 5
field::Field
    =
    variable:identifier '=' value:expression ';'
    ;

# event_def describes a mapping between a SMEDL event (labeled by event) for
# a specific monitor (labeled by monitor) and an event in the target program.
# The current rule defines two possible event types in the target program:
# update and call.
#
# The event_params list associated with the event is used to describe the values
# of an event's input parameters with values from the target program.
#
# An update block monitors a change in a variable's value. The parameter in the
# update block describes which variable to monitor (see the update_param rule).
#
# A call block monitors a call to a function in the target program. The
# parameter in the call block is the name function to be monitored.
#
# The 'when' keyword is followed by an expression defining conditions under
# which the event will be raised. Typically, this expression is to be used to
# manage distribution of the event to various monitors based on their
# identities (i.e. event filtering).
event_def::Event
    =
    monitor:identifier '(' monitor_params:identifier_list ').' event:identifier
        '(' [event_params:state_update_list] ')' '='
        ('update(' update_param ')' | 'call(' call_param:identifier ')')
        ['when' when:expression]
    ;

# update_param describes the form of a parameter in the update block. This
# parameter should always describe a variable in the target program. To
# describe a local variable, use dot notation to describe the function where
# the variable is defined followed by the variable's name. To describe a global
# variable, simply list the variable's name.
update_param::UpdateParam
    =
      update_fn:identifier '.' update_var:identifier
    | update_var:identifier
    ;

# state_update defines a generic statement wherein a target is updated based on
# the result of the right-hand expression.
state_update::StateUpdate
    =
      target:target '=' expression:expression
    ;

# identifier defines an alphanumeric string starting with a letter.
identifier::str
    =
    ?/[a-zA-Z][A-Za-z0-9_]*/?
    ;

# integer defines a numeric string with an optional neg/pos sign.
integer::int
    =
    ?/[-+]?[0-9]+/?
    ;

# float defines a numeric string with an optional neg/pos sign and an optional
# decimal point.
float::float
    =
    ?/[-+]?[0-9]*\.?[0-9]+/?
    ;

# expression breaks apart the parsing of an expression input into possible
# expression components. The following rules provide various ways to parse a
# subexpression.
expression
    =
      or_ex:and_expr {'||' or_ex:and_expr}+
    | @:and_expr
    ;

and_expr
    =
      and_ex:sub_expr {'&&' and_ex:sub_expr}+
    | @:sub_expr
    ;

sub_expr
    =
      {'!!'}*'!(' not_ex:expression ')'
    | {'!!'}*'(' @:expression ')'
    | @:comp_expr
    ;

comp_expr
    =
      comp:arith_expr {operator:('>=' | '<=' | '==' | '!=' | '>' | '<') comp:arith_expr}+
    | '(' @:comp_expr ')'
    | @:arith_expr
    ;

arith_expr
    =
      arith:term {operator:('+' | '-' | '*' | '/' | '%') arith:term}+
    | @:term
    ;

term
    =
      {unary:('+' | '-' | '~' | '!')}* atom:atom {trailer:trailer}*
    | {unary:('+' | '-' | '~')}* '(' @:arith_expr ')'
    ;

atom
    =
      integer
    | float
    | identifier
    | 'true'
    | 'false'
    | 'null'
    ;

trailer
    =
      '[' [index:expression] ']'
    | '(' [params:expression_list] ')'
    | '.' dot:identifier {trailer:trailer}*
    ;

target
    =
    identifier
    ;

# expression_list describes a list of expressions.
expression_list
    =
      @:expression {',' @:expression}*
    | ()
    ;

# identifier_list describes a list of identifiers.
identifier_list
    =
      @:identifier {',' @:identifier}*
    | ()
    ;

# state_update_list describes a list of state_updates.
state_update_list
    =
      @:state_update {',' @:state_update}*
    | ()
    ;
