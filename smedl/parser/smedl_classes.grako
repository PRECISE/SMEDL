# This grammar defines SMEDL in the Grako-variation of EBNF.
#  written by Peter Gebhard

# Grako-specific directives
@@grammar :: smedl

object::Object
    =
    imports+:{import}*
    'object' name:identifier
    ['identity' identities+:{variable_declaration}+]
    ['state' states+:{variable_declaration}+]
    'events'
        { 'internal' internal_events+:event_list
        | 'exported' exported_events+:event_list}*
        'imported' imported_events+:event_list
        { 'imported' imported_events+:event_list
        | 'internal' internal_events+:event_list
        | 'exported' exported_events+:event_list}*
    'scenarios'
        scenarios+:{scenario}+
    $
    ;

variable_declaration::VariableDeclaration
    =
    type:type var:identifier {',' var:identifier}* ';'
    ;

import
    =
    '#import' id:identifier
    ;

event::Event
    =
    error:['error'] id:identifier ['(' params:parameter_list ')'] ['=' definition:expression]
    ;

scenario::Scenario
    =
    atomic:['atomic'] id:identifier ':' traces:{trace}+
    ;

trace::Trace
    =
    start_state:identifier '->' {steps+:step '->'}+  end_state:identifier
          ['else' [else_actions:actions] '->' else_state:identifier]
    ;

step::Step
    =
      event:event_instance [actions:actions]
    ;

event_instance::EventInstance
    =
    expression:expression ['when' when:expression]
    ;

actions
    =
    '{' actions:action_list '}'
    ;

action::Action
    =
      state_update:state_update
    | raise:raise_stmt
    | instantiation:instantiation_stmt
    | call:call_stmt
    ;

state_update::StateUpdateStatement
    =
      target:target operator:('++' | '--')
    | target:target operator:'=' expression:expression
    ;

raise_stmt::RaiseStatement
    =
    'raise' id:identifier ['(' expr_list+:expression_list ')']
    ;

instantiation_stmt::InstantiationStatement
    =
    'new' id:identifier ['(' state_update_list+:state_update_list ')']
    ;

call_stmt::CallStatement
    =
      target:target '(' expr_list+:expression_list ')'
    ;

type::str
    =
    ?/[a-zA-Z][A-Za-z0-9_]*/?
    ;

identifier::str
    =
    ?/[a-zA-Z][A-Za-z0-9_]*/?
    ;

integer::int
    =
    ?/[-+]?[0-9]+/?
    ;

float::float
    =
    ?/[-+]?[0-9]*\.?[0-9]+/?
    ;

expression::Expression
    =
      or_ex:and_expr {'||' or_ex:and_expr}+
    | @:and_expr
    ;

and_expr
    =
      and_ex:sub_expr {'&&' and_ex:sub_expr}+
    | @:sub_expr
    ;

sub_expr
    =
      {'!!'}*'!(' not_ex:expression ')'
    | {'!!'}*'(' @:expression ')'
    | @:comp_expr
    ;

comp_expr
    =
      comp:arith_expr {operator:('>=' | '<=' | '==' | '!=' | '>' | '<') comp:arith_expr}+
    | '(' @:comp_expr ')'
    | @:arith_expr
    ;

arith_expr
    =
      arith:term {operator:('+' | '-' | '*' | '/' | '%') arith:term}+
    | @:term
    ;

term
    =
      {unary:('+' | '-' | '~' | '!')}* atom:atom {trailer:trailer}*
    | {unary:('+' | '-' | '~')}* '(' @:arith_expr ')'
    ;

atom
    =
      integer
    | float
    | identifier
    | 'true'
    | 'false'
    | 'null'
    ;

trailer
    =
      '[' [index:expression] ']'
    | '(' [params:expression_list] ')'
    | '.' dot:identifier {trailer:trailer}*
    ;

target
    =
    identifier
    ;

parameter_list
    =
      @:type {',' @:type}*
    | ()
    ;

expression_list
    =
      @:expression {',' @:expression}*
    | ()
    ;

event_list
    =
    @:event {',' @:event}* ';'
    ;

identifier_list
    =
      @:identifier {',' @:identifier}*
    | ()
    ;

state_update_list
    =
      @:state_update {',' @:state_update}*
    | ()
    ;

action_list
    =
      @:action {';' @:action}*
    ;
