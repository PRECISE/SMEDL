(*
 * This grammar defines SMEDL in the Grako-variation of EBNF.
 *
 * Written June 17 2014.
 *)

object
    =
    'object' object:identifier
    ['identity' identity+:{variable_declaration}+]
    ['state' state+:{variable_declaration}+]
    'events'
        'imported' imported_events+:event_definition_list
        ['exported' exported_events+:event_definition_list]
    'scenarios'
        scenarios+:{scenario_definition}+
    $
    ;

variable_declaration
    =
    type:type var:identifier {',' var:identifier}* ';'
    ;

event_definition
    =
    error:['error'] event_id:identifier ['(' params:parameter_list ')']
    ;

scenario_definition
    =
    atomic:['atomic'] scenario_id:identifier ':' traces:{trace_definition}+
    ;

(*
trace_definition
    =
    identifier '->' step_definition
    ;

step_definition
    =
      event_instance '->' step_definition
    | event_instance '->' [expression] [action]
          ['else' '->' [expression] [action]]
    ;
*)

(* TODO: test for other arrangements of 'else', add names to AST output, figure out why empty lists are appearing (ask author), construct symbol table with variables, build state machine from AST (python library?) *)

trace_definition
    =
    start:identifier '->' trace_event:event_instance [action] '->' @:step_definition
    ;

step_definition
    =
    step:(
      event_instance [action] '->' step_definition
          ['else' [action] '->' step_definition ]
    | identifier
          ['else' [action] '->' step_definition ]
    )
    ;

event_instance
    =
    expression:expression ['when' when:expression]
    ;

action
    =
    '{' actions+:nonempty_action_item_list '}'
    ;

action_item
    =
      state_update:state_update
    | raise:raise_stmt
    | instantiation:instantiation_stmt
    ;

state_update
    =
      target:target '=' expression:expression
    | target:target '(' expression_list+:expression_list ')'
    ;

raise_stmt
    =
    'raise' id:identifier ['(' expr_list+:expression_list ')']
    ;

instantiation_stmt
    =
    'new' id:identifier ['(' state_update_list+:state_update_list ')']
    ;

type
    =
    ?/[a-zA-Z][A-Za-z0-9_]*/?
    ;

identifier
    =
    ?/[a-zA-Z][A-Za-z0-9_]*/?
    ;

integer
    =
    ?/[-+]?[0-9]+/?
    ;

float
    =
    ?/[-+]?[0-9]*\.?[0-9]+/?
    ;

expression
    =
      @:and_expr {'||' or:and_expr}*
    | '!' not_expr:expression
    | '(' @:expression ')'
    ;

and_expr
    =
    @:comp_expr {'&&' and:comp_expr}*
    ;

comp_expr
    =
    @:arith_expr {operator:('>' | '<' | '>=' | '<=' | '==') comp:arith_expr}*
    ;

arith_expr
    =
    @:term {operator:('+' | '-' | '*' | '/' | '%') arith:term}*
    ;

term
    =
      {operator:('+' | '-' | '~')}* atom:atom {trailer:trailer}*
    ;

atom
    =
      integer
    | float
    | identifier
    | 'true'
    | 'false'
    | 'null'
    ;

trailer
    =
      '[' [index:expression] ']'
    | '(' [params:expression_list] ')'
    | '.' dot:identifier {trailer:trailer}*
    ;

target
    =
    (* To be improved *)
    identifier
    ;

parameter_list
    =
      @:type {',' @:type}*
    | ()
    ;

expression_list
    =
      @:expression {',' @:expression}*
    | ()
    ;

event_definition_list
    =
    @:event_definition {',' @:event_definition}*
    ;

identifier_list
    =
      @:identifier {',' @:identifier}*
    | ()
    ;

state_update_list
    =
      @:state_update {',' @:state_update}*
    | ()
    ;

nonempty_action_item_list
    =
      @:action_item {',' @:action_item}*
    ;
