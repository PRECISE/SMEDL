(*
 * This grammar defines SMEDL in the Grako-variation of EBNF.
 *
 * Written June 17 2014.
 *)

object
    =
    'object' identifier
    ['identity' {variable_declaration}+]
    ['state' {variable_declaration}+]
    'events'
        'imported' event_definition {',' event_definition}*
        ['exported' event_definition {',' event_definition}*]
    'scenarios'
        {scenario_definition}+
    $
    ;

variable_declaration
    =
    type identifier {',' identifier}* ';'
    ;

event_definition
    =
    ['error'] identifier ['(' parameter_list ')']
    ;

scenario_definition
    =
    ['atomic'] identifier ':' {trace_definition}+
    ;

trace_definition
    =
    identifier '->' step_definition
    ;

step_definition
    =
      event_instance '->' step_definition
    | event_instance '->' [expression] [action]
          ['else' '->' [expression] [action]]
    ;

event_instance
    =
    expression ['when' expression]
    ;

action
    =
    '{' nonempty_action_item_list '}'
    ;

action_item
    =
      state_update
    | raise_stmt
    | instantiation_stmt
    ;

state_update
    =
      target '=' expression
    | target '(' expression_list ')'
    ;

raise_stmt
    =
    'raise' identifier ['(' expression_list ')']
    ;

instantiation_stmt
    =
    'new' identifier ['(' state_update_list ')']
    ;

type
    =
    ?/[a-zA-Z][A-Za-z0-9_]*/?
    ;

identifier
    =
    ?/[a-zA-Z][A-Za-z0-9_]*/?
    ;

integer
    =
    ?/[-+]?[0-9]+/?
    ;

float
    =
    ?/[-+]?[0-9]*\.?[0-9]+/?
    ;

expression
    =
      and_expr {'||' and_expr}*
    | '!' expression
    | '(' expression ')'
    ;

and_expr
    =
    comp_expr {'&&' comp_expr}*
    ;

comp_expr
    =
    arith_expr {('>' | '<' | '>=' | '<=' | '==') arith_expr}*
    ;

arith_expr
    =
    term {('+' | '-') term}*
    ;

term
    =
    factor {('*' | '/' | '%') factor}*
    ;

factor
    =
      ('+' | '-' | '~') factor
    | atom {trailer}*
    ;

atom
    =
      integer
    | float
    | identifier
    | 'true'
    | 'false'
    | 'null'
    ;

trailer
    =
      '[' [expression] ']'
    | '(' [expression_list] ')'
    | '.' identifier {trailer}*
    ;

target
    =
    (* To be improved *)
    identifier
    ;

parameter_list
    =
      type {',' type}*
    | ()
    ;

expression_list
    =
      expression {',' expression}*
    | ()
    ;

identifier_list
    =
      identifier {',' identifier}*
    | ()
    ;

state_update_list
    =
      state_update {',' state_update}*
    | ()
    ;

nonempty_action_item_list
    =
      action_item {',' action_item}*
    ;