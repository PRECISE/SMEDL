#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals
from grako.parsing import graken, Parser
from grako.exceptions import *  # noqa


__version__ = '2014.06.27.16.13.29.04'

__all__ = [
    'smedlParser',
    'smedlSemanticParser',
    'smedlSemantics',
    'main'
]


class smedlParser(Parser):
    def __init__(self, whitespace=None, **kwargs):
        super(smedlParser, self).__init__(whitespace=whitespace, **kwargs)

    @graken()
    def _object_(self):
        self._token('object')
        self._identifier_()
        with self._optional():
            self._token('identity')

            def block0():
                self._variable_declaration_()
            self._positive_closure(block0)
        with self._optional():
            self._token('state')

            def block1():
                self._variable_declaration_()
            self._positive_closure(block1)
        self._token('events')
        self._token('imported')
        self._event_definition_()

        def block2():
            self._token(',')
            self._event_definition_()
        self._closure(block2)
        with self._optional():
            self._token('exported')
            self._event_definition_()

            def block3():
                self._token(',')
                self._event_definition_()
            self._closure(block3)
        self._token('scenarios')

        def block4():
            self._scenario_definition_()
        self._positive_closure(block4)

        self._check_eof()

    @graken()
    def _variable_declaration_(self):
        self._type_()
        self._identifier_()

        def block0():
            self._token(',')
            self._identifier_()
        self._closure(block0)
        self._token(';')

    @graken()
    def _event_definition_(self):
        with self._optional():
            self._token('error')
        self._identifier_()
        with self._optional():
            self._token('(')
            self._parameter_list_()
            self._token(')')

    @graken()
    def _scenario_definition_(self):
        with self._optional():
            self._token('atomic')
        self._identifier_()
        self._token(':')

        def block0():
            self._trace_definition_()
        self._positive_closure(block0)

    @graken()
    def _trace_definition_(self):
        self._identifier_()
        self._token('->')

        def block0():
            self._step_definition_()
        self._positive_closure(block0)

    @graken()
    def _step_definition_(self):
        self._event_instance_()
        self._token('->')
        with self._optional():
            self._action_()
        with self._optional():
            self._identifier_()
            with self._optional():
                self._token('(')
                self._state_update_list_()
                self._token(')')
        with self._optional():
            self._token('else')
            self._token('->')
            with self._optional():
                self._action_()
            with self._optional():
                self._identifier_()
                with self._optional():
                    self._token('(')
                    self._state_update_list_()
                    self._token(')')

    @graken()
    def _event_instance_(self):
        self._identifier_()
        self._token('(')
        self._identifier_list_()
        self._token(')')
        with self._optional():
            self._token('when')
            self._expression_()

    @graken()
    def _action_(self):
        self._token('{')
        self._nonempty_action_item_list_()
        self._token('}')

    @graken()
    def _action_item_(self):
        with self._choice():
            with self._option():
                self._state_update_()
            with self._option():
                self._raise_stmt_()
            with self._option():
                self._instantiation_stmt_()
            self._error('no available options')

    @graken()
    def _state_update_(self):
        with self._choice():
            with self._option():
                self._target_()
                self._token('=')
                self._expression_()
            with self._option():
                self._target_()
                self._token('(')
                self._expression_list_()
                self._token(')')
            self._error('no available options')

    @graken()
    def _raise_stmt_(self):
        self._token('raise')
        self._identifier_()
        self._token('(')
        self._expression_list_()
        self._token(')')

    @graken()
    def _instantiation_stmt_(self):
        self._token('new')
        self._identifier_()
        self._token('(')
        self._state_update_list_()
        self._token(')')

    @graken()
    def _type_(self):
        self._pattern(r'[a-zA-Z][A-Za-z0-9_]*')

    @graken()
    def _identifier_(self):
        self._pattern(r'[a-zA-Z][A-Za-z0-9_]*')

    @graken()
    def _integer_(self):
        self._pattern(r'[-+]?[0-9]+')

    @graken()
    def _float_(self):
        self._pattern(r'[-+]?[0-9]*\.?[0-9]+')

    @graken()
    def _expression_(self):
        with self._choice():
            with self._option():
                self._and_expr_()

                def block0():
                    self._token('||')
                    self._and_expr_()
                self._closure(block0)
            with self._option():
                self._token('!')
                self._expression_()
            with self._option():
                self._token('(')
                self._expression_()
                self._token(')')
            self._error('no available options')

    @graken()
    def _and_expr_(self):
        self._comp_expr_()

        def block0():
            self._token('&&')
            self._comp_expr_()
        self._closure(block0)

    @graken()
    def _comp_expr_(self):
        self._arith_expr_()

        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('>')
                    with self._option():
                        self._token('<')
                    with self._option():
                        self._token('>=')
                    with self._option():
                        self._token('<=')
                    with self._option():
                        self._token('==')
                    self._error('expecting one of: < <= == > >=')
            self._arith_expr_()
        self._closure(block0)

    @graken()
    def _arith_expr_(self):
        self._term_()

        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('+')
                    with self._option():
                        self._token('-')
                    self._error('expecting one of: + -')
            self._term_()
        self._closure(block0)

    @graken()
    def _term_(self):
        self._factor_()

        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('*')
                    with self._option():
                        self._token('/')
                    with self._option():
                        self._token('%')
                    self._error('expecting one of: % * /')
            self._factor_()
        self._closure(block0)

    @graken()
    def _factor_(self):
        with self._choice():
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('+')
                        with self._option():
                            self._token('-')
                        with self._option():
                            self._token('~')
                        self._error('expecting one of: + - ~')
                self._factor_()
            with self._option():
                self._atom_()

                def block1():
                    self._trailer_()
                self._closure(block1)
            self._error('no available options')

    @graken()
    def _atom_(self):
        with self._choice():
            with self._option():
                self._integer_()
            with self._option():
                self._float_()
            with self._option():
                self._identifier_()
            with self._option():
                self._token('true')
            with self._option():
                self._token('false')
            with self._option():
                self._token('null')
            self._error('expecting one of: false null true')

    @graken()
    def _trailer_(self):
        with self._choice():
            with self._option():
                self._token('[')
                with self._optional():
                    self._expression_()
                self._token(']')
            with self._option():
                self._token('(')
                with self._optional():
                    self._expression_list_()
                self._token(')')
            with self._option():
                self._token('.')
                self._identifier_()

                def block0():
                    self._trailer_()
                self._closure(block0)
            self._error('expecting one of: ( [')

    @graken()
    def _target_(self):
        self._identifier_()

    @graken()
    def _parameter_list_(self):
        with self._choice():
            with self._option():
                self._type_()

                def block0():
                    self._token(',')
                    self._type_()
                self._closure(block0)
            with self._option():
                pass
            self._error('no available options')

    @graken()
    def _expression_list_(self):
        with self._choice():
            with self._option():
                self._expression_()

                def block0():
                    self._token(',')
                    self._expression_()
                self._closure(block0)
            with self._option():
                pass
            self._error('no available options')

    @graken()
    def _identifier_list_(self):
        with self._choice():
            with self._option():
                self._identifier_()

                def block0():
                    self._token(',')
                    self._identifier_()
                self._closure(block0)
            with self._option():
                pass
            self._error('no available options')

    @graken()
    def _state_update_list_(self):
        with self._choice():
            with self._option():
                self._state_update_()

                def block0():
                    self._token(',')
                    self._state_update_()
                self._closure(block0)
            with self._option():
                pass
            self._error('no available options')

    @graken()
    def _nonempty_action_item_list_(self):
        self._action_item_()

        def block0():
            self._token(',')
            self._action_item_()
        self._closure(block0)


class smedlSemantics(object):
    def object(self, ast):
        return ast

    def variable_declaration(self, ast):
        return ast

    def event_definition(self, ast):
        return ast

    def scenario_definition(self, ast):
        return ast

    def trace_definition(self, ast):
        return ast

    def step_definition(self, ast):
        return ast

    def event_instance(self, ast):
        return ast

    def action(self, ast):
        return ast

    def action_item(self, ast):
        return ast

    def state_update(self, ast):
        return ast

    def raise_stmt(self, ast):
        return ast

    def instantiation_stmt(self, ast):
        return ast

    def type(self, ast):
        return ast

    def identifier(self, ast):
        return ast

    def integer(self, ast):
        return ast

    def float(self, ast):
        return ast

    def expression(self, ast):
        return ast

    def and_expr(self, ast):
        return ast

    def comp_expr(self, ast):
        return ast

    def arith_expr(self, ast):
        return ast

    def term(self, ast):
        return ast

    def factor(self, ast):
        return ast

    def atom(self, ast):
        return ast

    def trailer(self, ast):
        return ast

    def target(self, ast):
        return ast

    def parameter_list(self, ast):
        return ast

    def expression_list(self, ast):
        return ast

    def identifier_list(self, ast):
        return ast

    def state_update_list(self, ast):
        return ast

    def nonempty_action_item_list(self, ast):
        return ast


def main(filename, startrule, trace=False, whitespace=None):
    import json
    with open(filename) as f:
        text = f.read()
    parser = smedlParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace)
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

if __name__ == '__main__':
    import argparse
    import string
    import sys

    class ListRules(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print('Rules:')
            for r in smedlParser.rule_list():
                print(r)
            print()
            sys.exit(0)

    parser = argparse.ArgumentParser(description="Simple parser for smedl.")
    parser.add_argument('-l', '--list', action=ListRules, nargs=0,
                        help="list all rules and exit")
    parser.add_argument('-t', '--trace', action='store_true',
                        help="output trace information")
    parser.add_argument('-w', '--whitespace', type=str, default=string.whitespace,
                        help="whitespace specification")
    parser.add_argument('file', metavar="FILE", help="the input file to parse")
    parser.add_argument('startrule', metavar="STARTRULE",
                        help="the start rule for parsing")
    args = parser.parse_args()

    main(args.file, args.startrule, trace=args.trace, whitespace=args.whitespace)
