#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals
from grako.parsing import graken, Parser
from grako.exceptions import *  # noqa


__version__ = '2014.07.11.17.01.37.04'

__all__ = [
    'smedlParser',
    'smedlSemanticParser',
    'smedlSemantics',
    'main'
]


class smedlParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=True,
        **kwargs):
        super(smedlParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            **kwargs
        )

    @graken()
    def _object_(self):
        self._token('object')
        self._identifier_()
        self.ast['object'] = self.last_node
        with self._optional():
            self._token('identity')

            def block2():
                self._variable_declaration_()
            self._positive_closure(block2)

            self.ast._append('identity', self.last_node)
        with self._optional():
            self._token('state')

            def block4():
                self._variable_declaration_()
            self._positive_closure(block4)

            self.ast._append('state', self.last_node)
        self._token('events')
        self._token('imported')
        self._event_definition_list_()
        self.ast._append('imported_events', self.last_node)
        with self._optional():
            self._token('exported')
            self._event_definition_list_()
            self.ast._append('exported_events', self.last_node)
        self._token('scenarios')

        def block8():
            self._scenario_definition_()
        self._positive_closure(block8)

        self.ast._append('scenarios', self.last_node)
        self._check_eof()

        self.ast._define(
            ['object'],
            ['identity', 'state', 'imported_events', 'exported_events', 'scenarios']
        )

    @graken()
    def _variable_declaration_(self):
        self._type_()
        self.ast['type'] = self.last_node
        self._identifier_()
        self.ast['var'] = self.last_node

        def block2():
            self._token(',')
            self._identifier_()
            self.ast['var'] = self.last_node
        self._closure(block2)
        self._token(';')

        self.ast._define(
            ['type', 'var'],
            []
        )

    @graken()
    def _event_definition_(self):
        with self._optional():
            self._token('error')
        self.ast['error'] = self.last_node
        self._identifier_()
        self.ast['event_id'] = self.last_node
        with self._optional():
            self._token('(')
            self._parameter_list_()
            self.ast['params'] = self.last_node
            self._token(')')

        self.ast._define(
            ['error', 'event_id', 'params'],
            []
        )

    @graken()
    def _scenario_definition_(self):
        with self._optional():
            self._token('atomic')
        self.ast['atomic'] = self.last_node
        self._identifier_()
        self.ast['scenario_id'] = self.last_node
        self._token(':')

        def block3():
            self._trace_definition_()
        self._positive_closure(block3)

        self.ast['traces'] = self.last_node

        self.ast._define(
            ['atomic', 'scenario_id', 'traces'],
            []
        )

    @graken()
    def _trace_definition_(self):
        self._identifier_()
        self.ast['start'] = self.last_node
        self._token('->')
        self._event_instance_()
        self.ast['trace_event'] = self.last_node
        with self._optional():
            self._action_()
        self._token('->')
        self._step_definition_()
        self.ast['@'] = self.last_node

        self.ast._define(
            ['start', 'trace_event'],
            []
        )

    @graken()
    def _step_definition_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._event_instance_()
                    with self._optional():
                        self._action_()
                    self._token('->')
                    self._step_definition_()
                    with self._optional():
                        self._token('else')
                        with self._optional():
                            self._action_()
                        self._token('->')
                        self._step_definition_()
                with self._option():
                    self._identifier_()
                    with self._optional():
                        self._token('else')
                        with self._optional():
                            self._action_()
                        self._token('->')
                        self._step_definition_()
                self._error('no available options')
        self.ast['step'] = self.last_node

        self.ast._define(
            ['step'],
            []
        )

    @graken()
    def _event_instance_(self):
        self._expression_()
        self.ast['expression'] = self.last_node
        with self._optional():
            self._token('when')
            self._expression_()
            self.ast['when'] = self.last_node

        self.ast._define(
            ['expression', 'when'],
            []
        )

    @graken()
    def _action_(self):
        self._token('{')
        self._nonempty_action_item_list_()
        self.ast._append('actions', self.last_node)
        self._token('}')

        self.ast._define(
            [],
            ['actions']
        )

    @graken()
    def _action_item_(self):
        with self._choice():
            with self._option():
                self._state_update_()
                self.ast['state_update'] = self.last_node
            with self._option():
                self._raise_stmt_()
                self.ast['raise_'] = self.last_node
            with self._option():
                self._instantiation_stmt_()
                self.ast['inst'] = self.last_node
            self._error('no available options')

        self.ast._define(
            ['state_update', 'raise', 'inst'],
            []
        )

    @graken()
    def _state_update_(self):
        with self._choice():
            with self._option():
                self._target_()
                self.ast['target'] = self.last_node
                self._token('=')
                self._expression_()
                self.ast['expression'] = self.last_node
            with self._option():
                self._target_()
                self.ast['target'] = self.last_node
                self._token('(')
                self._expression_list_()
                self.ast._append('expression_list', self.last_node)
                self._token(')')
            self._error('no available options')

        self.ast._define(
            ['target', 'expression'],
            ['expression_list']
        )

    @graken()
    def _raise_stmt_(self):
        self._token('raise')
        self._identifier_()
        with self._optional():
            self._token('(')
            self._expression_list_()
            self._token(')')

    @graken()
    def _instantiation_stmt_(self):
        self._token('new')
        self._identifier_()
        with self._optional():
            self._token('(')
            self._state_update_list_()
            self._token(')')

    @graken()
    def _type_(self):
        self._pattern(r'[a-zA-Z][A-Za-z0-9_]*')

    @graken()
    def _identifier_(self):
        self._pattern(r'[a-zA-Z][A-Za-z0-9_]*')

    @graken()
    def _integer_(self):
        self._pattern(r'[-+]?[0-9]+')

    @graken()
    def _float_(self):
        self._pattern(r'[-+]?[0-9]*\.?[0-9]+')

    @graken()
    def _expression_(self):
        with self._choice():
            with self._option():
                self._and_expr_()
                self.ast['@'] = self.last_node

                def block1():
                    self._token('||')
                    self._and_expr_()
                    self.ast['or_'] = self.last_node
                self._closure(block1)
            with self._option():
                self._token('!')
                self._expression_()
                self.ast['not_expr'] = self.last_node
            with self._option():
                self._token('(')
                self._expression_()
                self.ast['@'] = self.last_node
                self._token(')')
            self._error('no available options')

        self.ast._define(
            ['or', 'not_expr'],
            []
        )

    @graken()
    def _and_expr_(self):
        self._comp_expr_()
        self.ast['@'] = self.last_node

        def block1():
            self._token('&&')
            self._comp_expr_()
            self.ast['and_'] = self.last_node
        self._closure(block1)

        self.ast._define(
            ['and'],
            []
        )

    @graken()
    def _comp_expr_(self):
        self._arith_expr_()
        self.ast['@'] = self.last_node

        def block1():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('>')
                    with self._option():
                        self._token('<')
                    with self._option():
                        self._token('>=')
                    with self._option():
                        self._token('<=')
                    with self._option():
                        self._token('==')
                    self._error('expecting one of: < <= == > >=')
            self.ast['operator'] = self.last_node
            self._arith_expr_()
            self.ast['comp'] = self.last_node
        self._closure(block1)

        self.ast._define(
            ['operator', 'comp'],
            []
        )

    @graken()
    def _arith_expr_(self):
        self._term_()
        self.ast['@'] = self.last_node

        def block1():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('+')
                    with self._option():
                        self._token('-')
                    with self._option():
                        self._token('*')
                    with self._option():
                        self._token('/')
                    with self._option():
                        self._token('%')
                    self._error('expecting one of: % * + - /')
            self.ast['operator'] = self.last_node
            self._term_()
            self.ast['arith'] = self.last_node
        self._closure(block1)

        self.ast._define(
            ['operator', 'arith'],
            []
        )

    @graken()
    def _term_(self):

        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('+')
                    with self._option():
                        self._token('-')
                    with self._option():
                        self._token('~')
                    self._error('expecting one of: + - ~')
            self.ast['operator'] = self.last_node
        self._closure(block0)
        self._atom_()
        self.ast['atom'] = self.last_node

        def block4():
            self._trailer_()
            self.ast['trailer'] = self.last_node
        self._closure(block4)

        self.ast._define(
            ['operator', 'atom', 'trailer'],
            []
        )

    @graken()
    def _atom_(self):
        with self._choice():
            with self._option():
                self._integer_()
            with self._option():
                self._float_()
            with self._option():
                self._identifier_()
            with self._option():
                self._token('true')
            with self._option():
                self._token('false')
            with self._option():
                self._token('null')
            self._error('expecting one of: false null true')

    @graken()
    def _trailer_(self):
        with self._choice():
            with self._option():
                self._token('[')
                with self._optional():
                    self._expression_()
                    self.ast['index'] = self.last_node
                self._token(']')
            with self._option():
                self._token('(')
                with self._optional():
                    self._expression_list_()
                    self.ast['params'] = self.last_node
                self._token(')')
            with self._option():
                self._token('.')
                self._identifier_()
                self.ast['dot'] = self.last_node

                def block3():
                    self._trailer_()
                    self.ast['trailer'] = self.last_node
                self._closure(block3)
            self._error('expecting one of: ( [')

        self.ast._define(
            ['index', 'params', 'dot', 'trailer'],
            []
        )

    @graken()
    def _target_(self):
        self._identifier_()

    @graken()
    def _parameter_list_(self):
        with self._choice():
            with self._option():
                self._type_()
                self.ast['@'] = self.last_node

                def block1():
                    self._token(',')
                    self._type_()
                    self.ast['@'] = self.last_node
                self._closure(block1)
            with self._option():
                pass
            self._error('no available options')

    @graken()
    def _expression_list_(self):
        with self._choice():
            with self._option():
                self._expression_()
                self.ast['@'] = self.last_node

                def block1():
                    self._token(',')
                    self._expression_()
                    self.ast['@'] = self.last_node
                self._closure(block1)
            with self._option():
                pass
            self._error('no available options')

    @graken()
    def _event_definition_list_(self):
        self._event_definition_()
        self.ast['@'] = self.last_node

        def block1():
            self._token(',')
            self._event_definition_()
            self.ast['@'] = self.last_node
        self._closure(block1)

    @graken()
    def _identifier_list_(self):
        with self._choice():
            with self._option():
                self._identifier_()
                self.ast['@'] = self.last_node

                def block1():
                    self._token(',')
                    self._identifier_()
                    self.ast['@'] = self.last_node
                self._closure(block1)
            with self._option():
                pass
            self._error('no available options')

    @graken()
    def _state_update_list_(self):
        with self._choice():
            with self._option():
                self._state_update_()
                self.ast['@'] = self.last_node

                def block1():
                    self._token(',')
                    self._state_update_()
                    self.ast['@'] = self.last_node
                self._closure(block1)
            with self._option():
                pass
            self._error('no available options')

    @graken()
    def _nonempty_action_item_list_(self):
        self._action_item_()
        self.ast['@'] = self.last_node

        def block1():
            self._token(',')
            self._action_item_()
            self.ast['@'] = self.last_node
        self._closure(block1)


class smedlSemantics(object):
    def object(self, ast):
        return ast

    def variable_declaration(self, ast):
        return ast

    def event_definition(self, ast):
        return ast

    def scenario_definition(self, ast):
        return ast

    def trace_definition(self, ast):
        return ast

    def step_definition(self, ast):
        return ast

    def event_instance(self, ast):
        return ast

    def action(self, ast):
        return ast

    def action_item(self, ast):
        return ast

    def state_update(self, ast):
        return ast

    def raise_stmt(self, ast):
        return ast

    def instantiation_stmt(self, ast):
        return ast

    def type(self, ast):
        return ast

    def identifier(self, ast):
        return ast

    def integer(self, ast):
        return ast

    def float(self, ast):
        return ast

    def expression(self, ast):
        return ast

    def and_expr(self, ast):
        return ast

    def comp_expr(self, ast):
        return ast

    def arith_expr(self, ast):
        return ast

    def term(self, ast):
        return ast

    def atom(self, ast):
        return ast

    def trailer(self, ast):
        return ast

    def target(self, ast):
        return ast

    def parameter_list(self, ast):
        return ast

    def expression_list(self, ast):
        return ast

    def event_definition_list(self, ast):
        return ast

    def identifier_list(self, ast):
        return ast

    def state_update_list(self, ast):
        return ast

    def nonempty_action_item_list(self, ast):
        return ast


def main(filename, startrule, trace=False, whitespace=None):
    import json
    with open(filename) as f:
        text = f.read()
    parser = smedlParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace)
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

if __name__ == '__main__':
    import argparse
    import string
    import sys

    class ListRules(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print('Rules:')
            for r in smedlParser.rule_list():
                print(r)
            print()
            sys.exit(0)

    parser = argparse.ArgumentParser(description="Simple parser for smedl.")
    parser.add_argument('-l', '--list', action=ListRules, nargs=0,
                        help="list all rules and exit")
    parser.add_argument('-t', '--trace', action='store_true',
                        help="output trace information")
    parser.add_argument('-w', '--whitespace', type=str, default=string.whitespace,
                        help="whitespace specification")
    parser.add_argument('file', metavar="FILE", help="the input file to parse")
    parser.add_argument('startrule', metavar="STARTRULE",
                        help="the start rule for parsing")
    args = parser.parse_args()

    main(args.file, args.startrule, trace=args.trace, whitespace=args.whitespace)
