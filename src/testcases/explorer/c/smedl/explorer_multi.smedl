object Explorer
identity
  opaque id;
state
  int x, y, heading, 
  struct explorer_view; 
events
  imported scan_view(int, int, int, struct), cleared(struct);
  internal found();
  exported retrieved();
  exported error not_cleared();
scenarios
  main:
    Explore -> found() -> Retrieve
    Retrieve -> retrieved() -> Explore

  explore:
    Stop -> scan_view(x, y, heading, map) when contains_object(this, map) { raise found() } -> Move
      else -> Move
    Move -> cleared(map) when !contains_object(this, map) { raise retrieved(); explorer_view = set_view(map) } -> Stop
      else {raise not_cleared(); set_view(map)} -> Stop

  // Add check that it doesn't go off the map
  // We can delay events...
  // Do higher-level state switches need to make other checkers aware of their transition to allow them to change their behavior
