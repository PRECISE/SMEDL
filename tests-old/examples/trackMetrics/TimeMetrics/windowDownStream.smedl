//when receiving heartbeat event, output the current result and begin updating the next round of metrics
//no heartbeat is used here
//depends on the number of message received to end the accumulation
//may change with different statistic requirement

object windowDownStream

identity
int id;


state
int numOfSubWindow;
int pro_buffer;
int sub_win_size;
int current_msg_num = 0;
int current_event_num = 0;
float current_least_ts = 0;
float current_largest_ts = 0;
float temp_observed_time = 0;
int b_ev_pre = 0;
int b_ev_pro = 0;
float cur_pro_buff_fst = 0;//ts
int allw = 0;
int t1;
int t2;

float begin_time = 0;
int del_flag = 0;

events
imported initial(int, float, int, int, int, int);//initialization of buffer
imported metric_sub(int, float, float, int);//flag
internal checkNum();
internal inner1( int, float, float);
internal inner2(float,float);
internal inner3(float);
internal check_end1();
internal check_end2();
internal output();
exported overall_metric(int, float, int);

scenarios

initialization:
//ts is the ts of the initial track
start -> initial(ts, sub_w, sub_size,  prob) {numOfSubWindow = sub_w; sub_win_size= sub_size
 ;  begin_time = ts;  pro_buffer = prob; allw = numOfSubWindow +pro_buffer; 
cur_pro_buff_fst = ts + sub_size * (numOfSubWindow ); 
 } -> start

accumulation:
//finalstates: ends;
start -> metric_sub(n,ft, lt, flag)  {current_msg_num ++; del_flag = flag;
 raise inner1(n,ft,lt); 
 } -> start

in1:

start -> inner1(n,ft,lt) when (lt <= cur_pro_buff_fst) {current_event_num = current_event_num + n; raise inner2(ft,lt);} -> start

//raise checkNum();

in1_:
start -> inner1(n,ft,lt) when (ft < begin_time + sub_win_size) {b_ev_pre = 1; 
} -> start

in1__:
start -> inner1(n,ft,lt) when (ft > cur_pro_buff_fst && n > 0) {b_ev_pro = 1; raise checkNum();
} -> start
start -> inner1(n,ft,lt) when (ft > cur_pro_buff_fst && n <= 0) {raise checkNum();
} -> start



ft_chk:
start -> inner2(ft,lt) when (current_least_ts == 0 || (
 ft < current_least_ts  && ft != 0)) { current_least_ts = ft; raise inner3(lt);
 } -> start
start -> inner2(ft,lt) when (!(current_least_ts == 0 || (
 ft < current_least_ts  && ft != 0))) { raise inner3(lt);
 } -> start

lt_chk:
start -> inner3(lt) 
when (lt > current_largest_ts
 ) { current_largest_ts
  = lt; raise checkNum();
 } -> start
start -> inner3(lt) when (!(lt > current_largest_ts))
{  raise checkNum();
 } -> start



output_chk:
start -> checkNum() when (current_msg_num == allw) { 
 raise check_end1();} -> start



check_e:
start -> check_end1() when (b_ev_pro == 1 && current_largest_ts != 0) {current_largest_ts = begin_time + sub_win_size * numOfSubWindow; raise check_end2();
 } -> start
start -> check_end1() when (!(b_ev_pro == 1 && current_largest_ts != 0)) {raise check_end2();
 } -> start

check_e2:
start -> check_end2() when (b_ev_pre == 1 && current_largest_ts != 0) {current_least_ts = begin_time ; raise output();
 } -> start

start -> check_end2() when (!(b_ev_pre == 1 && current_largest_ts != 0)) {raise output();
 current_least_ts = begin_time;} -> start

out:

start -> output()  { temp_observed_time = current_largest_ts - current_least_ts; raise overall_metric( current_event_num, temp_observed_time, del_flag);  current_event_num = 0;
 current_msg_num = 0; current_least_ts = 0; current_largest_ts = 0; 
cur_pro_buff_fst = cur_pro_buff_fst + sub_win_size; b_ev_pre = 0; b_ev_pro = 0; begin_time = begin_time + sub_win_size; raise checkDelete();
 } -> start

chk_del:
finalstates:  end;
start -> checkDelete() when (del_flag == 0) -> start
start -> checkDelete() when (del_flag == 1) -> end

