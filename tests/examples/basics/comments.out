--tests/examples/basics/comments_mon.h--
#include "monitor_map.h"
#include "actions.h"
#include <stdio.h> // For the log file
#include <amqp_tcp_socket.h>
#include <amqp.h>
#include <amqp_framing.h>
#include <pthread.h>

#define TEST_MONITOR_MAP_SIZE 100 // number of buckets
#define TEST_MONITOR_IDENTITIES 1

typedef struct TestData {
  void* id;

} TestData;

typedef struct TestMonitor {
  pthread_mutex_t monitor_lock;
  MonitorIdentity *identities[1];
  int state[2];

  action *action_queue;
  action *export_queue;
  const char *amqp_exchange;
  const char *ctrl_exchange;
  amqp_socket_t *recv_socket;
  amqp_connection_state_t recv_conn;
  amqp_socket_t *send_socket;
  amqp_connection_state_t send_conn;
} TestMonitor;

typedef struct TestMonitorRecord {
  TestMonitor *monitor;
  struct TestMonitorRecord *next;
} TestMonitorRecord;

typedef struct TestMonitorMap {
  TestMonitorRecord *list[TEST_MONITOR_MAP_SIZE];
} TestMonitorMap;

TestMonitorMap* test_monitor_maps[TEST_MONITOR_IDENTITIES]; //a map for each identity
pthread_mutex_t test_monitor_maps_lock;

TestMonitor* init_test_monitor(TestData*);
void start_monitor(TestMonitor* monitor);
void free_monitor(TestMonitor*);

/*
 * Monitor Event Handlers
 */
void test_foo(TestMonitor* monitor);
void raise_test_foo(TestMonitor* monitor);

/*
 * Monitor Utility Functions
 */
TestMonitorRecord* get_test_monitors();
TestMonitorRecord* get_test_monitors_by_identity(int, int, void*);
TestMonitorRecord* filter_test_monitors_by_identity(TestMonitorRecord*, int, void*);
int init_test_monitor_maps();
void free_test_monitor_maps();
int add_test_monitor_to_map(TestMonitor*, int);
int put_test_monitor(TestMonitor*); //puts into all maps
void raise_error(char*, const char*, char*, char*);
char* monitor_identities_str(MonitorIdentity**);

void executePendingEvents(TestMonitor* monitor);
void executeEvents(TestMonitor* monitor);
void executeExportedEvent(TestMonitor* monitor);
--tests/examples/basics/comments_mon.c--
//Compile: gcc -o comments_mon -std=c99 actions.c monitor_map.c comments_mon.c

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stdint.h>
#include <amqp_tcp_socket.h>
#include <amqp.h>
#include <amqp_framing.h>
#include <libconfig.h>
#include "utils.h"
#include "comments_mon.h"

typedef enum { TEST_ID } test_identity;
const identity_type test_identity_types[TEST_MONITOR_IDENTITIES] = { OPAQUE };

typedef enum { TEST_CHECK_SCENARIO, TEST_CHECK2_SCENARIO } test_scenario;
typedef enum { TEST_CHECK_START } test_check_state;
typedef enum { TEST_CHECK2_START } test_check2_state;
typedef enum { TEST_FOO_EVENT } test_event;
typedef enum { TEST_DEFAULT } test_error;
const char *test_check_states[1] = { "Start" };
const char *test_check2_states[1] = { "Start" };
const char **test_states_names[2] = { test_check_states, test_check2_states };


#define bindingkeyNum 1


TestMonitor* init_test_monitor( TestData *d ) {
    TestMonitor* monitor = (TestMonitor*)malloc(sizeof(TestMonitor));
    pthread_mutex_init(&monitor->monitor_lock, NULL);
    monitor->identities[TEST_ID] = init_monitor_identity(OPAQUE, d->id);
    monitor->state[TEST_CHECK_SCENARIO] = TEST_CHECK_START;
    monitor->state[TEST_CHECK2_SCENARIO] = TEST_CHECK2_START;
    monitor->action_queue = NULL;
    monitor->export_queue = NULL;

    /* Read settings from config file */
    config_t cfg;
    config_setting_t *setting;
    config_init(&cfg);
    if(!config_read_file(&cfg, "comments_mon.cfg")) {
        fprintf(stderr, "%s:%d - %s\n", config_error_file(&cfg),
            config_error_line(&cfg), config_error_text(&cfg));
        config_destroy(&cfg);
        exit(EXIT_FAILURE);
    }
    setting = config_lookup(&cfg, "rabbitmq");

    const char *hostname, *username, *password;
    int port;

    if (setting != NULL) {
        if (!config_setting_lookup_string(setting, "hostname", &hostname)) {
            fprintf(stderr, "%s:%d - %s\n", config_error_file(&cfg),
                config_error_line(&cfg), config_error_text(&cfg));
            config_destroy(&cfg);
            exit(EXIT_FAILURE);
        }
        config_setting_lookup_int(setting, "port", &port);
        config_setting_lookup_string(setting, "username", &username);
        config_setting_lookup_string(setting, "password", &password);
        config_setting_lookup_string(setting, "exchange", &(monitor->amqp_exchange));
        config_setting_lookup_string(setting, "ctrl_exchange", &(monitor->ctrl_exchange));
    }

    /* RabbitMQ initialization */
    amqp_bytes_t queuename;
    monitor->recv_conn = amqp_new_connection();
    monitor->recv_socket = amqp_tcp_socket_new(monitor->recv_conn);
    if (!monitor->recv_socket) {
        die("creating TCP socket");
    }
    int status = amqp_socket_open(monitor->recv_socket, hostname, port);
    if (status) {
        die("opening TCP socket");
    }
    die_on_amqp_error(amqp_login(monitor->recv_conn, "/", 0, 131072, 0,
        AMQP_SASL_METHOD_PLAIN, username, password), "Logging in");
    amqp_channel_open(monitor->recv_conn, 1);
    die_on_amqp_error(amqp_get_rpc_reply(monitor->recv_conn), "Opening channel");
    amqp_queue_declare_ok_t *r = amqp_queue_declare(monitor->recv_conn, 1,
        amqp_empty_bytes, 0, 0, 0, 1, amqp_empty_table);
    die_on_amqp_error(amqp_get_rpc_reply(monitor->recv_conn), "Declaring queue");
    queuename = amqp_bytes_malloc_dup(r->queue);
    if (queuename.bytes == NULL) {
        fprintf(stderr, "Out of memory while copying queue name");
        exit(EXIT_FAILURE);
    }

    monitor->send_conn = amqp_new_connection();
    monitor->send_socket = amqp_tcp_socket_new(monitor->send_conn);
    if (!monitor->send_socket) {
        die("creating TCP socket");
    }
    status = amqp_socket_open(monitor->send_socket, hostname, port);
    if (status) {
        die("opening TCP socket");
    }
    die_on_amqp_error(amqp_login(monitor->send_conn, "/", 0, 131072, 0,
        AMQP_SASL_METHOD_PLAIN, username, password), "Logging in");
    amqp_channel_open(monitor->send_conn, 1);

    die_on_amqp_error(amqp_get_rpc_reply(monitor->send_conn),
        "Opening channel");
    amqp_exchange_declare(monitor->send_conn, 1,
        amqp_cstring_bytes(monitor->amqp_exchange),
        amqp_cstring_bytes("topic"), 0, 1, 0, 0, amqp_empty_table);
    die_on_amqp_error(amqp_get_rpc_reply(monitor->send_conn),
        "Declaring primary exchange");
    amqp_exchange_declare(monitor->send_conn, 1,
        amqp_cstring_bytes(monitor->ctrl_exchange),
        amqp_cstring_bytes("fanout"), 0, 1, 0, 0, amqp_empty_table);
    die_on_amqp_error(amqp_get_rpc_reply(monitor->send_conn),
        "Declaring control exchange");

    // binding several binding keys
    char ** bindingkeys = (char**)malloc(bindingkeyNum*sizeof(char*));
    bindingkeys[0]=(char*)malloc(255*sizeof(char));
	strcpy(bindingkeys[0],"#");


    for(int i = 0; i < bindingkeyNum; i++){
        amqp_queue_bind(monitor->recv_conn, 1, queuename,
            amqp_cstring_bytes(monitor->amqp_exchange),
            amqp_cstring_bytes(bindingkeys[i]), amqp_empty_table);
    }

    die_on_amqp_error(amqp_get_rpc_reply(monitor->recv_conn), "Binding queue");
    amqp_basic_consume(monitor->recv_conn, 1, queuename, amqp_empty_bytes, 0, 1, 0, amqp_empty_table);
    die_on_amqp_error(amqp_get_rpc_reply(monitor->recv_conn), "Consuming");

    put_test_monitor(monitor);
    return monitor;
}

// mallocs a string for the event name
// returns null if the given string isn't a properly-terminated c string
char *getEventName(char *str, size_t maxlen){
    // make sure that str is really a cstring before trying to copy from it.
    size_t len = strnlen(str, maxlen);
    if (len >= maxlen) {
        return NULL;
    }
    // find the first space or the end of the string
    char* end = index(str, ' ');
    // copylen is the length of the string with the terminator
    size_t copylen;
    if (NULL == end) {
      copylen = maxlen - 1;
    } else {
      copylen = end - str;
    }
    char* eventName = malloc(copylen+1);
    memcpy(eventName, str, copylen);
    eventName[copylen] = '\0';
    return eventName;
}

char *getConnName(char *str, size_t maxlen){
    // make sure that str is really a cstring before trying to copy from it.
    size_t len = strnlen(str, maxlen);
    if (len >= maxlen) {
        return NULL;
    }
    // find the first space or the end of the string
    char* end = index(str, '.');
    // copylen is the length of the string with the terminator
    size_t copylen;
    if (NULL == end) {
        copylen = maxlen - 1;
    } else {
        copylen = end - str;
    }
    char* connName = malloc(copylen+1);
    memcpy(connName, str, copylen);
    connName[copylen] = '\0';
    return connName;
}


void start_monitor(TestMonitor* monitor) {
    int received = 0;
    amqp_frame_t frame;

    // Announce that the monitor has started
    char* ids = monitor_identities_str(monitor->identities);
    char* ann = malloc(strlen(ids)+50);
    sprintf(ann, "Test monitor (%s) started.", ids);
    free(ids);
    die_on_error(amqp_basic_publish(monitor->send_conn,
                                    1,
                                    amqp_cstring_bytes(monitor->ctrl_exchange),
                                    amqp_cstring_bytes("smedl.control"), // Ignored due to fanout exchange
                                    0,
                                    0,
                                    NULL,
                                    amqp_cstring_bytes(ann)),
                "Publishing Test monitor startup announcement");
    free(ann);

    while (1) {
        amqp_rpc_reply_t ret;
        amqp_envelope_t envelope;
        amqp_maybe_release_buffers(monitor->recv_conn);
        ret = amqp_consume_message(monitor->recv_conn, &envelope, NULL, 0);
        amqp_message_t msg = envelope.message;
        amqp_bytes_t bytes = msg.body;
        amqp_bytes_t routing_key = envelope.routing_key;
        char* rk = (char*)routing_key.bytes;
        char* string = (char*)bytes.bytes;
        //char* event[255] = {NULL};

        if (string != NULL) {
            char* eventName = strtok(rk, ".");
            if (eventName != NULL) {
                char e[255];

                

            }
            //free(eventName);
        }

        if (AMQP_RESPONSE_NORMAL != ret.reply_type) {
            if (AMQP_RESPONSE_LIBRARY_EXCEPTION == ret.reply_type &&
                AMQP_STATUS_UNEXPECTED_STATE == ret.library_error) {
                if (AMQP_STATUS_OK != amqp_simple_wait_frame(monitor->recv_conn, &frame)) {
                    return;
                }

                if (AMQP_FRAME_METHOD == frame.frame_type) {
                    switch (frame.payload.method.id) {
                        case AMQP_BASIC_ACK_METHOD:
                            /* if we've turned publisher confirms on, and we've published a message
                             * here is a message being confirmed
                             */
                            printf("AMQP_BASIC_ACK_METHOD\n");
                            break;
                        case AMQP_BASIC_RETURN_METHOD:
                            /* if a published message couldn't be routed and the mandatory flag was set
                             * this is what would be returned. The message then needs to be read.
                             */
                            printf("AMQP_BASIC_RETURN_METHOD\n");
                            amqp_message_t message;
                            ret = amqp_read_message(monitor->recv_conn, frame.channel, &message, 0);
                            if (AMQP_RESPONSE_NORMAL != ret.reply_type) {
                                return;
                            }
                            amqp_destroy_message(&message);
                            break;

                        case AMQP_CHANNEL_CLOSE_METHOD:
                            /* a channel.close method happens when a channel exception occurs, this
                             * can happen by publishing to an exchange that doesn't exist for example
                             *
                             * In this case you would need to open another channel redeclare any queues
                             * that were declared auto-delete, and restart any consumers that were attached
                             * to the previous channel
                             */
                            return;

                        case AMQP_CONNECTION_CLOSE_METHOD:
                            /* a connection.close method happens when a connection exception occurs,
                             * this can happen by trying to use a channel that isn't open for example.
                             *
                             * In this case the whole connection must be restarted.
                             */
                            return;

                        default:
                            fprintf(stderr ,"An unexpected method was received %u\n", frame.payload.method.id);
                            return;
                    }
                }
            }
        } else {
            amqp_destroy_envelope(&envelope);
        }
        received++;
    }
}

void send_message(TestMonitor* monitor, char* message, char* routing_key) {
    amqp_bytes_t message_bytes;
    message_bytes.len = strlen(message)+1;
    message_bytes.bytes = message;
    amqp_bytes_t routingkey_bytes;
    routingkey_bytes.len = strlen(routing_key)+1;
    routingkey_bytes.bytes = routing_key;
    die_on_error(amqp_basic_publish(monitor->send_conn,
                                    1,
                                    amqp_cstring_bytes(monitor->amqp_exchange),
                                    routingkey_bytes,
                                    0,
                                    0,
                                    NULL,
                                    message_bytes),
                 "Publishing");
    
}

void free_monitor(TestMonitor* monitor) {
    die_on_amqp_error(amqp_channel_close(monitor->send_conn, 1, AMQP_REPLY_SUCCESS), "Closing channel");
    die_on_amqp_error(amqp_connection_close(monitor->send_conn, AMQP_REPLY_SUCCESS), "Closing connection");
    die_on_error(amqp_destroy_connection(monitor->send_conn), "Ending connection");
    free(monitor);
}

//called at the end of each event handling function
void executeEvents(TestMonitor* monitor){
    if(monitor->action_queue != NULL){
        executePendingEvents(monitor);
    }
    
    if(monitor->action_queue == NULL && monitor->export_queue != NULL){
        executeExportedEvent(monitor);
    }
}

void executePendingEvents(TestMonitor* monitor){
    action** head = &monitor->action_queue;
    
    while(*head!=NULL){
        int type = (*head)->id;
        param *params = (*head)->params;
        param *p_head = params;
        switch (type){
            }
        pop_action(head);
    }
}

//send export events one by one from export_queue
void executeExportedEvent(TestMonitor* monitor){
    action** head = &monitor->export_queue;
    
    while(*head != NULL){
        int type = (*head)->id;
        param *params = (*head)->params;
        param *p_head = params;
        switch (type) {
            }
        pop_action(head);
    }
    
}


/*
 * Monitor Event Handlers
 */

void test_foo(TestMonitor* monitor) {
  switch (monitor->state[TEST_CHECK_SCENARIO]) {
    case TEST_CHECK_START:
      monitor->state[TEST_CHECK_SCENARIO] = TEST_CHECK_START;
      break;

    default:
      raise_error("test_check", test_states_names[TEST_CHECK_SCENARIO][monitor->state[TEST_CHECK_SCENARIO]], "foo", "DEFAULT");
      break;
  }
  switch (monitor->state[TEST_CHECK2_SCENARIO]) {
    case TEST_CHECK2_START:
      monitor->state[TEST_CHECK2_SCENARIO] = TEST_CHECK2_START;
      break;

    default:
      raise_error("test_check2", test_states_names[TEST_CHECK2_SCENARIO][monitor->state[TEST_CHECK2_SCENARIO]], "foo", "DEFAULT");
      break;
  }
executeEvents(monitor);
}



void raise_test_foo(TestMonitor* monitor) {
  param *p_head = NULL;
  push_action(&monitor->action_queue, TEST_FOO_EVENT, p_head);
}


/*
 * Monitor Utility Functions
 */

int init_test_monitor_maps() {
    if (pthread_mutex_init(&test_monitor_maps_lock, NULL) != 0) {
        printf("\nTest Monitor map mutex init failed\n");
        return 0;
    }
    for(int i = 0; i < TEST_MONITOR_IDENTITIES; i++) {
        test_monitor_maps[i] = (TestMonitorMap*)malloc(sizeof(TestMonitorMap));
    }
    return 1;
}

void free_test_monitor_maps() {
    // TODO
}

int add_test_monitor_to_map(TestMonitor *monitor, int identity) {
    TestMonitorMap* map = test_monitor_maps[identity];
    int bucket = hash_monitor_identity(monitor->identities[identity]->type,
        monitor->identities[identity]->value, TEST_MONITOR_MAP_SIZE);
    TestMonitorRecord* record = (TestMonitorRecord*)malloc(sizeof(TestMonitorRecord));
    if(monitor == NULL || record == NULL) {
        free(monitor);
        free(record);
        return 0;
    }
    record->monitor = monitor;
    pthread_mutex_lock(&test_monitor_maps_lock);
    record->next = map->list[bucket];
    map->list[bucket] = record;
    pthread_mutex_unlock(&test_monitor_maps_lock);
    return 1;
}

int put_test_monitor(TestMonitor *monitor) {
    return add_test_monitor_to_map(monitor, TEST_ID);
}

TestMonitorRecord* get_test_monitors() {
    TestMonitorRecord* results = NULL;
    TestMonitorMap* map = test_monitor_maps[0];
    for(int i = 0; i < TEST_MONITOR_MAP_SIZE; i++) {
        TestMonitorRecord* current = map->list[i];
        while(current != NULL) {
            TestMonitorRecord* record = (TestMonitorRecord*)malloc(sizeof(TestMonitorRecord));
            record->monitor = current->monitor;
            record->next = results;
            results = record;
            current = current->next;
        }
    }
    return results;
}

TestMonitorRecord* get_test_monitors_by_identity(int identity, int type, void *value) {
    TestMonitorRecord* results = NULL;
    TestMonitorMap* map = test_monitor_maps[identity];
    int bucket = hash_monitor_identity(type, value, TEST_MONITOR_MAP_SIZE);
    TestMonitorRecord* current = map->list[bucket];
    while(current != NULL) {
        if(compare_monitor_identity(value, current->monitor->identities[identity])) {
            TestMonitorRecord* record = (TestMonitorRecord*)malloc(sizeof(TestMonitorRecord));
            record->monitor = current->monitor;
            record->next = results;
            results = record;
        }
        current = current->next;
    }
    return results;
}

TestMonitorRecord* filter_test_monitors_by_identity(TestMonitorRecord* before, int identity, void  *value) {
    TestMonitorRecord* results = NULL;
    while(before != NULL) {
        if(compare_monitor_identity(value, before->monitor->identities[identity])) {
            TestMonitorRecord* record = (TestMonitorRecord*)malloc(sizeof(TestMonitorRecord));
            record->monitor = before->monitor;
            record->next = results;
            results = record;
        }
        before = before->next;
    }
    return results;
}

void raise_error(char *scen, const char *state, char *action, char *type) {
    printf("{\"scenario\":\"%s\", \"state\":\"%s\", \"action\":\"%s\", \"type\":\"%s\"}\n", scen, state, action, type);
}

char* monitor_identities_str(MonitorIdentity** identities) {
    char* out = malloc(20*TEST_MONITOR_IDENTITIES);
    out[0] = '\0';
    for(int i = 0; i < TEST_MONITOR_IDENTITIES; i++) {
        char* monid_str = monitor_identity_str(identities[i]);
        if (i == 0) {
            strcat(out, monid_str);
        }
        else {
            strcat(out, ", ");
            strcat(out, monid_str);
        }
        free(monid_str);
    }
    return out;
}
--actions.h--
#ifndef ACTIONS_H
#define ACTIONS_H

typedef struct Parameter param;
struct Parameter {
  int type;
  int i;
  char c;
  double d;
  const void *v;
  param *next;
};

int push_param(param**, int*, char*, double*, const void**);
void pop_param(param**);

typedef struct Action action;
struct Action {
  int id;
  param *params;
  action *next;
};

int push_action(action**, int, param*);
void pop_action(action**);

#endif
--actions.c--
#include <stdlib.h>
#include <stdio.h>
#include "actions.h"

int push_param(param **head, int *i, char *c, double *d, const void **v) {
    param *new = (param*)malloc(sizeof(param));
    if(new == NULL) {
        free(new);
        return 0;
    }
    if(i != NULL) {
        new->i = *i;
    }
    if(c != NULL) {
        new->c = *c;
    }
    if(d != NULL) {
        new->d = *d;
    }
    if(v != NULL) {
        new->v = *v;
    }
    new->next = NULL;
    if(*head == NULL) {
        *head = new;
        return 1;
    }
    param *current = *head;
    while(current->next != NULL) {
        current = current->next;
    }
    current->next = new;
    return 1;
}

void pop_param(param **head) {
    if(head != NULL && *head != NULL) {
        param *old = *head;
        *head = (*head)->next;
        free(old);
    }
}

int push_action(action **head, int id, param *params) {
    action *new = (action*)malloc(sizeof(action));
    if(new == NULL) {
        free(new);
        return 0;
    }
    new->id = id;
    new->params = params;
    new->next = NULL;
    if(*head == NULL) {
        *head = new;
        return 1;
    }
    action *current = *head;
    while((current)->next != NULL) {
        current = current->next;
    }
    current->next = new;
    return 1;
}

void pop_action(action **head) {
    if(head != NULL && *head != NULL) {
        action *old = *head;
        *head = (*head)->next;
        free(old);
    }
}
--monitor_map.h--
#ifndef MONITOR_MAP_H
#define MONITOR_MAP_H

typedef enum { INT, POINTER, THREAD, OPAQUE } identity_type;

typedef struct MonitorIdentity {
  identity_type type;
  void *value;
} MonitorIdentity;

MonitorIdentity* init_monitor_identity(identity_type, void*);
int compare_monitor_identity(void*, MonitorIdentity*);
int hash_monitor_identity(identity_type, void*, int);
char* monitor_identity_str(MonitorIdentity*);

#endif
--monitor_map.c--
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <pthread.h>
#include "monitor_map.h"

MonitorIdentity* init_monitor_identity(identity_type type, void *value) {
    MonitorIdentity* identity = (MonitorIdentity*)malloc(sizeof(MonitorIdentity));
    int *i = (int*)malloc(sizeof(int));
    uintptr_t *p = (uintptr_t*)malloc(sizeof(uintptr_t));
    pthread_t *t = (pthread_t*)malloc(sizeof(pthread_t));
    identity->type = type;
    switch (type) {
        case INT:
        case OPAQUE:
            *i = *(int*)value;
            identity->value = i;
            free(p);
            free(t);
            break;
        case POINTER:
            *p = (uintptr_t)value;
            identity->value = p;
            free(i);
            free(t);
            break;
        case THREAD:
            *t = *(pthread_t*)value;
            identity->value = t;
            free(i);
            free(p);
            break;
        default:
            free(i);
            free(p);
            free(t);
            break;
    }
    return identity;
}

int compare_monitor_identity(void *value, MonitorIdentity *other) {
    int value_match = 0;
    switch (other->type) {
        case INT:
        case OPAQUE:
            if(*(int*)value == *(int*)other->value) {
                value_match = 1;
            }
            break;
        case POINTER:
            if(*(uintptr_t*)value == *(uintptr_t*)other->value) {
                value_match = 1;
            }
            break;
        case THREAD:
            if(*(pthread_t*)value == *(pthread_t*)other->value) {
                value_match = 1;
            }
            break;
        default:
            break;
    }
    return value_match;
}

int hash_monitor_identity(identity_type type, void *value, int map_size) {
    int bucket;
    switch (type) {
        case INT:
        case OPAQUE:
            bucket = *(int*)value % map_size;
            break;
        case POINTER:
            bucket = (int)(*(uintptr_t*)value) % map_size;
            break;
        case THREAD:
            bucket = (int)(*(pthread_t*)value) % map_size;
            break;
        default:
            break;
    }
    return bucket;
}

char* monitor_identity_str(MonitorIdentity *id) {
    char* out = malloc(20);
    out[0] = '\0';
    switch (id->type) {
        case INT:
        case OPAQUE:
            sprintf(out, "%d", *(int*)id->value);
            break;
        case POINTER:
            sprintf(out, "%02x", (int)*(uintptr_t*)id->value);
            break;
        case THREAD:
            sprintf(out, "%02x", (int)*(pthread_t*)id->value);
            break;
        default:
            out[0] = '\0';
            break;
    }
    return out;
}
--utils.h--
/* vim:set ft=c ts=2 sw=2 sts=2 et cindent: */
#ifndef librabbitmq_examples_utils_h
#define librabbitmq_examples_utils_h

/*
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MIT
 *
 * Portions created by Alan Antonuk are Copyright (c) 2012-2013
 * Alan Antonuk. All Rights Reserved.
 *
 * Portions created by VMware are Copyright (c) 2007-2012 VMware, Inc.
 * All Rights Reserved.
 *
 * Portions created by Tony Garnock-Jones are Copyright (c) 2009-2010
 * VMware, Inc. and Tony Garnock-Jones. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * ***** END LICENSE BLOCK *****
 */

void die(const char *fmt, ...);
extern void die_on_error(int x, char const *context);
extern void die_on_amqp_error(amqp_rpc_reply_t x, char const *context);

extern void amqp_dump(void const *buffer, size_t len);

extern uint64_t now_microseconds(void);
extern void microsleep(int usec);

#endif
--utils.c--
/* vim:set ft=c ts=2 sw=2 sts=2 et cindent: */
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MIT
 *
 * Portions created by Alan Antonuk are Copyright (c) 2012-2013
 * Alan Antonuk. All Rights Reserved.
 *
 * Portions created by VMware are Copyright (c) 2007-2012 VMware, Inc.
 * All Rights Reserved.
 *
 * Portions created by Tony Garnock-Jones are Copyright (c) 2009-2010
 * VMware, Inc. and Tony Garnock-Jones. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * ***** END LICENSE BLOCK *****
 */

#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include <stdint.h>
#include <amqp.h>
#include <amqp_framing.h>

#include <time.h>
#include <sys/time.h>
#include <unistd.h>

uint64_t now_microseconds(void)
{
  struct timeval tv;
  gettimeofday(&tv, NULL);
  return (uint64_t) tv.tv_sec * 1000000 + (uint64_t) tv.tv_usec;
}

void microsleep(int usec)
{
  struct timespec req;
  req.tv_sec = 0;
  req.tv_nsec = 1000 * usec;
  nanosleep(&req, NULL);
}

void die(const char *fmt, ...)
{
  va_list ap;
  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  fprintf(stderr, "\n");
  exit(1);
}

void die_on_error(int x, char const *context)
{
  if (x < 0) {
    fprintf(stderr, "%s: %s\n", context, amqp_error_string2(x));
    exit(1);
  }
}

void die_on_amqp_error(amqp_rpc_reply_t x, char const *context)
{
  switch (x.reply_type) {
  case AMQP_RESPONSE_NORMAL:
    return;

  case AMQP_RESPONSE_NONE:
    fprintf(stderr, "%s: missing RPC reply type!\n", context);
    break;

  case AMQP_RESPONSE_LIBRARY_EXCEPTION:
    fprintf(stderr, "%s: %s\n", context, amqp_error_string2(x.library_error));
    break;

  case AMQP_RESPONSE_SERVER_EXCEPTION:
    switch (x.reply.id) {
    case AMQP_CONNECTION_CLOSE_METHOD: {
      amqp_connection_close_t *m = (amqp_connection_close_t *) x.reply.decoded;
      fprintf(stderr, "%s: server connection error %uh, message: %.*s\n",
              context,
              m->reply_code,
              (int) m->reply_text.len, (char *) m->reply_text.bytes);
      break;
    }
    case AMQP_CHANNEL_CLOSE_METHOD: {
      amqp_channel_close_t *m = (amqp_channel_close_t *) x.reply.decoded;
      fprintf(stderr, "%s: server channel error %uh, message: %.*s\n",
              context,
              m->reply_code,
              (int) m->reply_text.len, (char *) m->reply_text.bytes);
      break;
    }
    default:
      fprintf(stderr, "%s: unknown server error, method id 0x%08X\n", context, x.reply.id);
      break;
    }
    break;
  }

  exit(1);
}

static void dump_row(long count, int numinrow, int *chs)
{
  int i;

  printf("%08lX:", count - numinrow);

  if (numinrow > 0) {
    for (i = 0; i < numinrow; i++) {
      if (i == 8) {
        printf(" :");
      }
      printf(" %02X", chs[i]);
    }
    for (i = numinrow; i < 16; i++) {
      if (i == 8) {
        printf(" :");
      }
      printf("   ");
    }
    printf("  ");
    for (i = 0; i < numinrow; i++) {
      if (isprint(chs[i])) {
        printf("%c", chs[i]);
      } else {
        printf(".");
      }
    }
  }
  printf("\n");
}

static int rows_eq(int *a, int *b)
{
  int i;

  for (i=0; i<16; i++)
    if (a[i] != b[i]) {
      return 0;
    }

  return 1;
}

void amqp_dump(void const *buffer, size_t len)
{
  unsigned char *buf = (unsigned char *) buffer;
  long count = 0;
  int numinrow = 0;
  int chs[16];
  int oldchs[16] = {0};
  int showed_dots = 0;
  size_t i;

  for (i = 0; i < len; i++) {
    int ch = buf[i];

    if (numinrow == 16) {
      int j;

      if (rows_eq(oldchs, chs)) {
        if (!showed_dots) {
          showed_dots = 1;
          printf("          .. .. .. .. .. .. .. .. : .. .. .. .. .. .. .. ..\n");
        }
      } else {
        showed_dots = 0;
        dump_row(count, numinrow, chs);
      }

      for (j=0; j<16; j++) {
        oldchs[j] = chs[j];
      }

      numinrow = 0;
    }

    count++;
    chs[numinrow++] = ch;
  }

  dump_row(count, numinrow, chs);

  if (numinrow != 0) {
    printf("%08lX:\n", count);
  }
}
