object Explorer
identity
  opaque id;
state
  int mon_x, mon_y, mon_heading, interest_threshold,move_count;
events
  imported view(pointer), drive(int, int, int), turn(int),count();
  internal found();
  exported retrieved(int);
scenarios
  main:
    Explore -> found() -> Retrieve
    Retrieve -> retrieved(cnt) -> Explore
  explore:
    Look -> view(view_pointer) when contains_object(view_pointer) { raise found() } -> Move
      else -> Move
    Move -> turn(facing) when facing != mon_heading {mon_heading = facing } -> Look
      else -> Move
    Move -> drive(x, y, heading) when x == mon_x && y == mon_y { raise retrieved(move_count); move_count = 0 } -> Look
      else {mon_x = x; mon_y = y} -> Look
  count:
    Start -> count(){move_count = move_count + 1} -> Start

  // Add check that it doesn't go off the map
  // We can delay events...
  // Do higher-level state switches need to make other checkers aware of their transition to allow them to change their behavior

  /*
  mud:
    Drive -> "slow down" -> Drive
  ice:
    Drive -> "slower turns" -> Drive
  turn:
    Drive -> "perform turn" -> Drive
  climb:
    Drive -> "slow down" -> Drive
  obstacle:
    Drive -> turn() -> drive() -> Drive
  hill:
    Drive -> "prepare to climb" -> Drive


  Have an event that would update all state variables...

  Event ordering is such that variables update immmediately, events are queued
  */
