object frontend

state
int measurementCount = 0;
int consumerCount = 0;
int responseCount = 0;
float sum = 0;

events
imported measurementIn(int, float);
exported measurementOut(int, float);
internal checkCount();
imported newConsumer();
exported requestAverages();
imported averageResponse(float);
internal checkSum();
exported raiseAlarm();
exported resetAlarm();

scenarios

countMeasurements:
idle
-> measurementIn(id, usage) {raise measurementOut(id, usage); measurementCount++; raise checkCount();}
-> idle

gatherAverages:
idle
-> checkCount() when (measurementCount >= 5) {measurementCount = 0; responseCount = 1; sum = 0; raise requestAverages();}
-> awaiting_responses
idle
-> checkCount() when (measurementCount < 5)
-> idle
awaiting_responses
-> averageResponse(average) when (responseCount < consumerCount) {sum = sum + average; responseCount++;}
-> awaiting_responses
awaiting_responses
-> averageResponse(average) when (responseCount >= consumerCount) {sum = sum + average; raise checkSum();}
-> idle

countConsumers:
idle
-> newConsumer() {consumerCount++;}
-> idle

handleAlarms:
no_alarm
-> checkSum() when (sum < 10)
-> no_alarm
no_alarm
-> checkSum() when (sum >= 10) {raise raiseAlarm();}
-> yes_alarm
yes_alarm
-> checkSum() when (sum >=10)
-> yes_alarm
yes_alarm
-> checkSum() when (sum < 10) {raise resetAlarm();}
-> no_alarm
